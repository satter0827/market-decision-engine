# 内部設計書（アーキテクチャ設計）

## market-decision-engine

### 0. 本書の目的と範囲

本書は、`market-decision-engine` の内部構造について、実装者が迷わないために次を言語化する。

* 何をどの層（モジュール）が責任として持つか（責務境界）
* なぜその境界が必要か（設計意図）
* どの方向に依存すべきか（依存方向の思想）
* 変更の影響範囲をどう最小化するか（拡張・段階導入）

本書は、個別アルゴリズムや式、型定義の詳細には踏み込まない（それらはコード・スキーマ・テストで担保する）。

---

## 1. アーキテクチャ方針

### 1.1 One-way Pipeline（非循環）

本システムは EOD バッチとして、**一方向にのみ流れるパイプライン**を採用する。
理由は次のとおり。

* 再現性（同一入力→同一出力）を最優先するため
* 障害時に「どこまで完了したか」を判別しやすくするため
* 段階リリースで機能追加しても、既存工程を破壊しにくいため

改善（学習・閾値更新・戦略追加など）は、日次パイプラインの外側で行う（週次/月次）。

### 1.2 Contract-First（契約優先）

内部のモジュール境界は、**Pydantic スキーマ（契約）**を中心に据える。
ただし本書ではスキーマ自体は扱わず、**契約が存在する前提で境界責務のみを定義**する。

### 1.3 “混ぜるな危険”の構造化

特徴量は daily/static/fundamental として分離される。これは単なる実装方針ではなく、**誤った因果混入（リーク）や恣意的最適化を防ぐための安全設計**である。

* daily：価格決定（Entry/Stop/Target）と候補抽出の根拠
* static：事故率低減（流動性・集中度等）による「可否・サイズ補正」
* fundamental：ML評価の段階導入のみに使用（初期は任意）

### 1.4 LLM is Translator（翻訳器）

LLM は意思決定器ではなく、**決まった数値を人間が読める形に翻訳・監査するだけ**とする。
この制約は、品質というよりも **責任境界（誰が何を決めるか）**のために必要である。

---

## 2. レイヤ構造（概念）

内部は、次の5層に分けて考える。

1. **Domain Contracts（契約）**
   外部/内部の境界で受け渡しされる不変のデータ構造（スキーマ、語彙）
2. **Pure Logic（計算）**
   戦略、Execution、補正、スコアリング等の決定論的計算
3. **Orchestration（制御）**
   EODパイプラインとして順に呼び出し、失敗時の縮退を適用
4. **Integration（外部接続）**
   yfinance、メール、LLM API 等のI/O
5. **Presentation（出力整形）**
   JSON/Markdown 等への整形、通知文の組み立て

この分割の目的は、「変更の波及範囲」を制限することにある。
特に外部接続（Integration）を中核計算（Pure Logic）から分離し、テスト容易性と再現性を担保する。

---

## 3. モジュール責務（内部の役割分担）

以下は「何をどこでやるか」の合意であり、細部仕様はコード化する。

### 3.1 `pipeline/`（Orchestration）

**責務**

* EODの手続きを順序通りに実行する
* Step間の入出力を接続する
* 失敗時の縮退（スキップ/停止/保守化）を適用する
* run_id、asof、market など実行コンテキストを統括する

**やらないこと**

* 価格・スコアの計算ロジックを持たない（持つと拡張で破綻する）
* 外部I/Oの実装詳細を抱えない（integrationに委譲）

### 3.2 `data/`（Integration）

**責務**

* 市場データを取得し、一定の整形（欠損・型・時系列整合）を行う
* 取得不能/欠損の扱いを「データ取得の問題」として明確化する

**設計意図**

* 欠損やAPI不安定性は必ず発生するため、「失敗の局所化」を行う
  （＝この層の問題として警告・除外し、下流の計算層を汚染しない）

### 3.3 `features/`（Pure Logic）

**責務**

* ohlcv等から daily/static/fundamental を生成する
* リーク・未来情報混入を避ける（asof基準で閉じる）

**設計意図**

* 未来情報混入は、後から結果が良く見える最悪のバグであり、構造で防ぐ

### 3.4 `regime/`（Pure Logic）

**責務**

* market_env（相場環境）の判定と、その結果を下流へ提供する

**設計意図**

* 相場環境は「候補抽出・サイズ制御」を変えるが、価格の決定（Entry/Stop）に直接混ぜない
  （価格決定に混ぜると説明不可能になりやすい）

### 3.5 `selection/`（Pure Logic）

**責務**

* 候補銘柄の抽出とランキングの基礎計算
* 候補抽出は daily のみを根拠として完結する

**設計意図**

* 静的特徴量や財務特徴量で候補を作り始めると、説明困難・恣意性が増す
  候補抽出は「価格の振る舞い」という最も検証しやすい軸に固定する

### 3.6 `plans/`（Domain+Pure Logic）

**責務**

* plan_catalog に基づき、試行する plan_args を列挙する
* 「戦略の候補空間」をコードではなくカタログ中心で管理する

**設計意図**

* 戦略追加は頻繁に起きるため、コード改変を最小にする（差分を小さくする）

### 3.7 `execution/`（Pure Logic）

**責務**

* Entry/Stop/Target/TimeStop/Size の計算を決定論で生成する

**設計意図**

* 本システムの“発注可能性”の中核
* ここが不安定だと、全体が「スコアしか出ない分析ツール」に退行する
* 価格計算は daily のみで完結させ、説明可能性を維持する

### 3.8 `risk/`（Pure Logic）

**責務**

* 価格を変えずに「サイズ・可否」のみを補正する
* 流動性、集中、相場環境などによる保守化を適用する

**設計意図**

* “価格計算”と“可否/サイズ”を混ぜると、原因切り分けが困難になる
* 補正は必ず安全側に倒す（増やすのではなく減らす）

### 3.9 `models/`（Pure Logic + Integration要素）

**責務**

* p_success / ev_r / uncertainty の推定（段階導入）
* ML が不調でもパイプラインが成立するように、縮退可能にする

**設計意図**

* MLは価値を上げるが、依存すると運用が崩れる
* “MLがあると良いが、なくても動く” を内部構造で担保する

### 3.10 `decision/`（Pure Logic）

**責務**

* plan比較（optimizer）と、最終的な buy_signal を確定する
* DecisionCoreを不変オブジェクトとして確定する

**設計意図**

* 最終判断の一貫性と監査性を担保するため、決定点を一か所に集中させる

### 3.11 `llm/`（Integration + Presentation）

**責務**

* ShortSummary を生成・監査する（翻訳器）
* 違反時はテンプレへフォールバックする

**設計意図**

* LLMの自由度を“自然言語の範囲”に閉じ込める
* 数値と意思決定は deterministic な系に残す

### 3.12 `reports/`（Presentation）

**責務**

* 出力フォーマット（json/md/email body）への整形
* 配信経路ごとの差分吸収

**設計意図**

* 「中身の意味（decision）」と「見せ方（report）」を分けて、変更を局所化する

---

## 4. 依存方向の思想（コード化しにくい部分のみ）

依存関係のルール自体はコード（import制約テスト等）で強制できるが、**なぜ守るべきか**は文書化が必要である。

### 4.1 依存の基本原則

* 中核計算（execution/decision/risk）は、外部接続（yfinance/LLM/Email）に依存しない
  → テスト容易性と再現性の確保
* Orchestration（pipeline）は、計算層を呼ぶが、計算層は pipeline を知らない
  → 再利用性（将来API化/バッチ変更）を確保
* Presentation（reports）は、中身の意味を変えない
  → 表現変更で結果が変わる事故を防ぐ

### 4.2 典型的な“破壊パターン”と禁止理由（言語化）

* execution が static を参照し始める
  → Entry/Stop の根拠が曖昧化し、説明不能になる。改善時に何が効いたか分からない。
* selection が LLM を参照する
  → 候補抽出が非決定論化し、再現性が崩れる。
* decision が data loader に依存する
  → テスト時にI/Oが混入し、障害切り分けが困難になる。

---

## 5. 失敗の扱い（内部設計の合意事項）

失敗時の振る舞い自体はコード化できるが、ここでは「方針」と「判断基準の考え方」を残す。

* 失敗は「局所化」する（銘柄単位でスキップ）
* 市場全体停止は、入力契約違反や設定不備など“全件に影響する”と判断できる場合に限定する
* 不明な場合は安全側（NO）へ倒す
  これは性能よりも、運用上の信頼を守ることを優先した方針である

---

## 6. 段階リリースと拡張点（設計上の狙い）

段階リリース（M1→）で内部構造が壊れないよう、拡張点を予め固定する。

* M1：data → features(daily) → selection → execution → decision → reports
* M2：risk/static補正、キャッシュ、縮退強化
* M3：regime、ML導入、LLM要約強化
* M4以降：fundamental、改善ループ、通知最適化

拡張は原則として「新しいモジュール追加」または「カタログ追加」で行い、既存の契約を破壊しない。

---

## 7. 本書の“境界”（ここから先はコードで担保）

以下は重要だが、**規約としてコード化できる**ため、本書では詳細を定義しない。

* Pydantic の具体スキーマ（型、値域、必須/任意）
* plan_catalog / vocabulary の実体
* 各アルゴリズム（Entry/Stop/Score）の数式・閾値
* CI、lint、type、test の設定詳細

---

## 8. まとめ

本アーキテクチャは、以下を守るための構造である。

* 再現性（非循環・決定論）
* 説明可能性（price計算の根拠をdailyに固定）
* 安全性（縮退で運用を壊さない）
* 段階リリース耐性（変更の局所化）
* LLM統制（翻訳器として閉じ込め）

---
